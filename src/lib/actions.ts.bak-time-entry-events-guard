"use client";

import { createClient } from "@/lib/supabase/client";
import type {
  ClockInResponse,
  ClockOutResponse,
  Project,
} from "@/types/database";

export type ManagerClockOutResponse = ClockOutResponse & {
  employee_id?: string;
  project_id?: string;
  clock_out?: string;
};

type SupabaseError = {
  message: string;
  details?: string | null;
};

type TimeEntryEventType = "clock_in" | "clock_out" | "manager_clock_out" | "edit";

type TimeEntryEventPayload = {
  time_entry_id: string;
  event_type: TimeEntryEventType;
  occurred_at?: string;
  lat?: number;
  lng?: number;
  project_id?: string;
  source?: string;
  metadata?: Record<string, unknown>;
};

function formatSupabaseError(error: SupabaseError): string {
  const details = error.details?.trim();
  return details ? `${error.message} (${details})` : error.message;
}

async function logTimeEntryEventBestEffort(
  payload: TimeEntryEventPayload
): Promise<void> {
  try {
    const response = await fetch("/api/time-entries/event", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      cache: "no-store",
      body: JSON.stringify(payload),
    });

    if (!response.ok && process.env.NODE_ENV !== "production") {
      const failurePayload = (await response.json().catch(() => ({}))) as {
        error?: string;
      };
      console.error("[time-entry-events] failed to log event", {
        status: response.status,
        error: failurePayload.error ?? "unknown",
        event_type: payload.event_type,
      });
    }
  } catch (error) {
    if (process.env.NODE_ENV !== "production") {
      console.error("[time-entry-events] event logging request failed", error);
    }
  }
}

export async function clockIn(
  projectId: string,
  lat: number,
  lng: number
): Promise<ClockInResponse> {
  const supabase = createClient();

  const { data, error } = await supabase.rpc("clock_in", {
    p_project_id: projectId,
    p_lat: lat,
    p_lng: lng,
  });

  if (error) {
    return { error: error.message };
  }

  const result = data as ClockInResponse;
  if (result.entry_id) {
    void logTimeEntryEventBestEffort({
      time_entry_id: result.entry_id,
      event_type: "clock_in",
      lat,
      lng,
      project_id: projectId,
      source: "web",
    });
  }

  return result;
}

export async function clockOut(
  lat?: number,
  lng?: number
): Promise<ClockOutResponse> {
  const supabase = createClient();

  const { data, error } = await supabase.rpc("clock_out", {
    p_lat: lat || null,
    p_lng: lng || null,
  });

  if (error) {
    return { error: error.message };
  }

  const result = data as ClockOutResponse;
  if (result.entry_id) {
    const payload: TimeEntryEventPayload = {
      time_entry_id: result.entry_id,
      event_type: "clock_out",
      source: "web",
    };

    if (typeof lat === "number") payload.lat = lat;
    if (typeof lng === "number") payload.lng = lng;
    void logTimeEntryEventBestEffort(payload);
  }

  return result;
}

export async function managerClockOutEntry(
  employeeId: string,
  projectId: string,
  businessId?: string
): Promise<ManagerClockOutResponse> {
  try {
    const response = await fetch("/api/time-entries/manager-clock-out", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        employee_id: employeeId,
        project_id: projectId,
        business_id: businessId ?? null,
      }),
    });

    const payload = (await response
      .json()
      .catch(() => ({ error: "Failed to parse server response." }))) as
      | ManagerClockOutResponse
      | { error?: string };

    if (!response.ok) {
      return { error: payload.error || "Unable to clock out employee." };
    }

    return payload as ManagerClockOutResponse;
  } catch {
    return { error: "Unable to clock out employee. Please try again." };
  }
}

export async function createProject(
  data: Omit<Project, "id" | "created_at" | "updated_at" | "created_by">
): Promise<{ project?: Project; error?: string }> {
  const supabase = createClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) return { error: "Not authenticated" };

  const { data: project, error } = await supabase
    .from("projects")
    .insert({ ...data, created_by: user.id })
    .select()
    .single();

  if (error) return { error: error.message };
  return { project: project as Project };
}

export async function updateProject(
  id: string,
  data: Partial<
    Pick<Project, "name" | "address" | "lat" | "lng" | "geo_radius_m" | "status">
  >
): Promise<{ project?: Project; error?: string }> {
  const supabase = createClient();

  const { data: project, error } = await supabase
    .from("projects")
    .update(data)
    .eq("id", id)
    .select()
    .single();

  if (error) return { error: error.message };
  return { project: project as Project };
}

export async function deleteProject(id: string): Promise<{ error?: string }> {
  const supabase = createClient();
  const { error } = await supabase.from("projects").delete().eq("id", id);
  if (error) return { error: error.message };
  return {};
}

export async function signIn(email: string, password: string) {
  const supabase = createClient();

  const { data, error } = await supabase.auth.signInWithPassword({
    email,
    password,
  });

  if (error) return { error: formatSupabaseError(error) };
  return { user: data.user, session: data.session };
}

export async function signOut() {
  const supabase = createClient();
  await supabase.auth.signOut();
}
